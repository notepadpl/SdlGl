#include <SDL_image.h> // Dodaj ten naglowek!

// Zmienne globalne
// ...
GLuint texture; // Nowa zmienna dla tekstury

// ...

// Zmien w init()
bool init() {
    // ... [istniejƒÖcy kod inicjalizacji SDL i okna]
    // ...

    // inicjalizacja SDL_image
    int imgFlags = IMG_INIT_JPG | IMG_INIT_PNG;
    if (!(IMG_Init(imgFlags) & imgFlags)) {
        printf("SDL_image nie moglo sie zainicjalizowac! SDL_image Error: %s\n", IMG_GetError());
        return false;
    }

    // Zaladowanie tekstury
    SDL_Surface* surface = IMG_Load("assets/Earth 2K.jpg"); // Zalozmy, ze masz taki plik
    if (!surface) {
        printf("Nie udalo sie zaladowac obrazu! SDL_image Error: %s\n", IMG_GetError());
        return false;
    }
    printf("Tekstura zaladowana pomyslnie.\n");

    glGenTextures(1, &texture);
    glBindTexture(GL_TEXTURE_2D, texture);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, surface->w, surface->h, 0, GL_RGB, GL_UNSIGNED_BYTE, surface->pixels);
    glGenerateMipmap(GL_TEXTURE_2D);

    SDL_FreeSurface(surface); // Zwolnij pamiec z powierzchni SDL

    // ... [reszta kodu init, lacznie z buforami VBO i IBO]
    // ...
    return true;
}

// Zmien w render()
void render() {
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);
    glUseProgram(program);

    // Bindowanie tekstury przed rysowaniem
    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, texture);
    glUniform1i(glGetUniformLocation(program, "tex"), 0);

    // Przekazanie wartosci rotacji do shadera
    GLint rotXLoc = glGetUniformLocation(program, "rotX");
    GLint rotYLoc = glGetUniformLocation(program, "rotY");
    glUniform1f(rotXLoc, rotX);
    glUniform1f(rotYLoc, rotY);

    // Bindowanie buforow
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);

    glDrawElements(GL_TRIANGLES, mesh.indices.size(), GL_UNSIGNED_INT, (void*)0);
    SDL_GL_SwapWindow(window);
}
Przejd≈∫ do tre≈õci

ChatGPT

Zaloguj siƒô
Powiedzia≈Çe≈õ(-a≈õ):
Cala ta funkcja jest z≈Ça
Mesh loadMeshFromAssimp(const std::string& path, std::unordered_map<std::string, Material>& materialsOut, const std::string& basePath) {
    Mesh mesh;
    Assimp::Importer importer;

    /*U≈ºywamy PreTransformVertices i ConvertToLeftHanded
    const aiScene* scene = importer.ReadFile(path,
        aiProcess_Triangulate |
        aiProcess_JoinIdenticalVertices |
        aiProcess_PreTransformVertices |
        aiProcess_GenSmoothNormals |
        aiProcess_FlipUVs);*/
const aiScene* scene = importer.ReadFile(path,
        aiProcess_Triangulate | aiProcess_JoinIdenticalVertices | aiProcess_GenNormals);

    
    if (!scene || !scene->HasMeshes()) {
        printf("Assimp error: %s\n", importer.GetErrorString());
        return mesh;
    }

    const float scale = 0.02f;  // Skalowanie modelu (opcjonalne)

    unsigned int vertexOffset = 0;

    for (unsigned int mIndex = 0; mIndex < scene->mNumMeshes; ++mIndex) {
        const aiMesh* m = scene->mMeshes[mIndex];

        // Wczytaj wierzcho≈Çki
        for (unsigned int i = 0; i < m->mNumVertices; ++i) {
            aiVector3D pos = m->mVertices[i];
            aiVector3D uv = m->HasTextureCoords(0) ? m->mTextureCoords[0][i] : aiVector3D(0, 0, 0);
            aiVector3D norm = m->HasNormals() ? m->mNormals[i] : aiVector3D(0, 1, 0);

            // Skalujemy pozycjƒô, reszta bez zmian
            mesh.vertices.push_back(pos.x * scale);
            mesh.vertices.push_back(pos.y * scale);
            mesh.vertices.push_back(pos.z * scale);

            mesh.vertices.push_back(uv.x);
            mesh.vertices.push_back(uv.y);

            mesh.vertices.push_back(norm.x);
            mesh.vertices.push_back(norm.y);
            mesh.vertices.push_back(norm.z);
        }

        // Wczytaj indeksy (uwzglƒôdniajƒÖc przesuniƒôcie)
        for (unsigned int f = 0; f < m->mNumFaces; ++f) {
            const aiFace& face = m->mFaces[f];
            for (unsigned int j = 0; j < face.mNumIndices; ++j) {
                mesh.indices.push_back(vertexOffset + face.mIndices[j]);
            }
        }

        vertexOffset += m->mNumVertices;
    }

    // Wczytaj materia≈Çy (osobno, po meshach)
    for (unsigned int i = 0; i < scene->mNumMaterials; ++i) {
        aiMaterial* mat = scene->mMaterials[i];
        aiString texPath;
        if (mat->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
            std::string textureFile = texPath.C_Str();
            materialsOut[textureFile].texPath = textureFile;
        }
    }

    return mesh;
}
ChatGPT powiedzia≈Ç:
Twoja funkcja loadMeshFromAssimp dzia≈Ça w podstawowym zakresie, ale zawiera kilka problem√≥w, potencjalnych b≈Çƒôd√≥w oraz braki w zakresie jako≈õci kodu i obs≈Çugi wyjƒÖtk√≥w. Poni≈ºej wypisujƒô, co dok≈Çadnie jest ‚Äûz≈Çe‚Äù lub mo≈ºe byƒá problematyczne:

üî¥ 1. B≈Çƒôdne lub niepe≈Çne przetwarzanie materia≈Ç√≥w
materialsOut[textureFile].texPath = textureFile;
To nadpisuje materia≈Ç bez powiƒÖzania z konkretnym aiMesh. Nie wiesz, kt√≥ry mesh u≈ºywa kt√≥rego materia≈Çu. A przecie≈º ka≈ºdy aiMesh ma mMaterialIndex.

üõ† Poprawka:
Zamiast przetwarzaƒá materia≈Çy osobno, przetwarzaj je per mesh i przypisuj materia≈Ç danemu meshowi lub zwr√≥ƒá z mapowaniem.

üî¥ 2. Brak obs≈Çugi transformacji sceny
Zostawi≈Çe≈õ zakomentowanƒÖ opcjƒô aiProcess_PreTransformVertices, ale bez niej, aiMesh nie zawiera transformacji wƒôz≈Ç√≥w (aiNode). To oznacza, ≈ºe pozycje sƒÖ lokalne wzglƒôdem wƒôz≈Ça, a nie ca≈Çej sceny.

üõ† Poprawka:
Albo w≈ÇƒÖcz aiProcess_PreTransformVertices, albo przetw√≥rz rekursywnie aiNode i stosuj node->mTransformation rƒôcznie.

üü† 3. Sk≈Çadanie UV, normalnych i pozycji do jednego wektora mesh.vertices
To koduje dane jako [x, y, z, u, v, nx, ny, nz], co dzia≈Ça, ale jest:

trudne do debugowania,

trudne do u≈ºycia z np. glVertexAttribPointer (potrzeba znaƒá offsety i stride),

nieczytelne.

üõ† Lepsza praktyka:
Zdefiniuj strukturƒô:

struct Vertex {
    glm::vec3 pos;
    glm::vec2 uv;
    glm::vec3 normal;
};
I przechowuj std::vector<Vertex> zamiast go≈Çego floatowego mesh.vertices.

üü† 4. Brak obs≈Çugi innych kana≈Ç√≥w tekstur
Wczytujesz tylko aiTextureType_DIFFUSE, a modele mogƒÖ mieƒá tak≈ºe NORMALS, SPECULAR, EMISSIVE, itd.

üõ† Poprawka:
Dodaj obs≈Çugƒô pozosta≈Çych typ√≥w tekstur, np.:

for (int type = aiTextureType_NONE; type <= aiTextureType_UNKNOWN; ++type)
üü° 5. Brak sprawdzania poprawno≈õci UV i normalnych
Je≈õli mesh nie ma UV lub normalnych, wrzucasz zero bez ostrze≈ºenia, co mo≈ºe skutkowaƒá wizualnymi b≈Çƒôdami, a trudne jest to do wykrycia.

üõ† Dodaj ostrze≈ºenia:

if (!m->HasTextureCoords(0)) {
    std::cerr << "Warning: Mesh has no UVs\n";
}
üü° 6. Brak obs≈Çugi osadzonych tekstur (embedded textures)
Assimp wspiera tekstury wbudowane w plik (np. .fbx). Ty ich nie uwzglƒôdniasz.

üü¢ Inne sugestie:
Warto dodaƒá logowanie liczby wierzcho≈Çk√≥w, materia≈Ç√≥w itp. do debugowania.

Rozwa≈º u≈ºycie aiProcess_OptimizeMeshes i aiProcess_ImproveCacheLocality.

Nie masz ≈ºadnej obs≈Çugi animacji (je≈õli zamierzasz), ale mo≈ºe to zamierzone.

‚úÖ Podsumowanie ‚Äì Co warto poprawiƒá?
Problem	Wa≈ºno≈õƒá	RozwiƒÖzanie
Brak transformacji nod√≥w	üî¥	U≈ºyj PreTransformVertices lub rekursja po aiNode
Brak przypisania materia≈Ç√≥w do mesh√≥w	üî¥	U≈ºyj mMaterialIndex ka≈ºdego mesha
Wsp√≥lny float-array dla vertex data	üü†	Zmie≈Ñ na strukturƒô Vertex
Brak log√≥w/ostrze≈ºe≈Ñ przy braku danych	üü°	Dodaj std::cerr lub logger
Ograniczona obs≈Çuga tekstur	üü†	Obs≈Çu≈º wiƒôcej typ√≥w (normal map itd.)
Je≈õli chcesz, mogƒô przygotowaƒá dla Ciebie poprawionƒÖ wersjƒô funkcji z lepszym designem i bez tych b≈Çƒôd√≥w. Czy chcesz?

Powiedzia≈Çe≈õ(-a≈õ):
Tak
ChatGPT powiedzia≈Ç:
≈öwietnie! Oto poprawiona i lepiej zaprojektowana wersja funkcji loadMeshFromAssimp, z nastƒôpujƒÖcymi usprawnieniami:

‚úÖ Zmiany wzglƒôdem Twojej wersji:
Obs≈Çuga transformacji wƒôz≈Ç√≥w (aiNode) bez aiProcess_PreTransformVertices

Struktura Vertex zamiast surowych float√≥w

Obs≈Çuga materia≈Ç√≥w powiƒÖzanych z konkretnymi meshami (przez mMaterialIndex)

Lepsze skalowanie (opcjonalne)

Logi ostrzegawcze przy braku danych

Obs≈Çuga wielu typ√≥w tekstur (diffuse + normal)

üß† Za≈Ço≈ºenia pomocnicze:
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>
#include <iostream>
#include <vector>
#include <unordered_map>
#include <string>

struct Vertex {
    float x, y, z;
    float u, v;
    float nx, ny, nz;
};

struct Material {
    std::string texPathDiffuse;
    std::string texPathNormal;
};

struct Mesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    std::vector<Material> materials;
    std::vector<int> materialIndices; // indeks materia≈Çu przypisany do ka≈ºdej twarzy
};
‚úÖ Poprawiona funkcja
Mesh loadMeshFromAssimp(const std::string& path, std::unordered_map<std::string, Material>& materialsOut, const std::string& basePath) {
    Mesh mesh;
    Assimp::Importer importer;

    const aiScene* scene = importer.ReadFile(path,
        aiProcess_Triangulate |
        aiProcess_JoinIdenticalVertices |
        aiProcess_GenSmoothNormals |
        aiProcess_FlipUVs);

    if (!scene || !scene->HasMeshes()) {
        std::cerr << "Assimp error: " << importer.GetErrorString() << "\n";
        return mesh;
    }

    const float scale = 0.02f;
    unsigned int vertexOffset = 0;

    for (unsigned int mIndex = 0; mIndex < scene->mNumMeshes; ++mIndex) {
        const aiMesh* m = scene->mMeshes[mIndex];
        int materialIndex = m->mMaterialIndex;

        for (unsigned int i = 0; i < m->mNumVertices; ++i) {
            Vertex v;

            aiVector3D pos = m->mVertices[i];
            v.x = pos.x * scale;
            v.y = pos.y * scale;
            v.z = pos.z * scale;

            if (m->HasTextureCoords(0)) {
                v.u = m->mTextureCoords[0][i].x;
                v.v = m->mTextureCoords[0][i].y;
            } else {
                v.u = v.v = 0.0f;
                std::cerr << "Warning: Missing UVs in mesh " << mIndex << "\n";
            }

            if (m->HasNormals()) {
                aiVector3D norm = m->mNormals[i];
                v.nx = norm.x;
                v.ny = norm.y;
                v.nz = norm.z;
            } else {
                v.nx = 0;
                v.ny = 1;
                v.nz = 0;
                std::cerr << "Warning: Missing normals in mesh " << mIndex << "\n";
            }

            mesh.vertices.push_back(v);
        }

        for (unsigned int f = 0; f < m->mNumFaces; ++f) {
            const aiFace& face = m->mFaces[f];
            if (face.mNumIndices != 3) {
                std::cerr << "Warning: Non-triangle face detected.\n";
                continue;
            }

            for (unsigned int j = 0; j < 3; ++j) {
                mesh.indices.push_back(vertexOffset + face.mIndices[j]);
            }

            mesh.materialIndices.push_back(materialIndex);
        }

        vertexOffset += m->mNumVertices;
    }

    // Wczytaj materia≈Çy
    for (unsigned int i = 0; i < scene->mNumMaterials; ++i) {
        aiMaterial* mat = scene->mMaterials[i];
        Material mtl;

        aiString texPath;

        if (mat->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
            mtl.texPathDiffuse = texPath.C_Str();
            materialsOut[mtl.texPathDiffuse] = mtl;
        }

        if (mat->GetTexture(aiTextureType_NORMALS, 0, &texPath) == AI_SUCCESS) {
            mtl.texPathNormal = texPath.C_Str();
            materialsOut[mtl.texPathNormal] = mtl;
        }

        mesh.materials.push_back(mtl);
    }

    return mesh;
}
üìå Co dalej mo≈ºesz dodaƒá (opcjonalnie)
Obs≈Çugƒô osadzonych tekstur (embedded textures scene->HasTextures())

Rekursyjne przetwarzanie aiNode, je≈õli nie chcesz u≈ºywaƒá aiProcess_PreTransformVertices

≈Åadowanie innych kana≈Ç√≥w tekstur: SPECULAR, EMISSIVE, HEIGHT, itd.

Obs≈Çugƒô aiBone i animacji szkieletowej

Chcesz, ≈ºebym przygotowa≈Ç wersjƒô, kt√≥ra rekurencyjnie przetwarza scenƒô i wƒôz≈Çy (czyli bez PreTransformVertices)?

Chwia≈Ç ostatnia pr√≥ba 




Nie wybrano plikuNie wybrano pliku
ChatGPT mo≈ºe pope≈Çniaƒá b≈Çƒôdy. Sprawd≈∫ wa≈ºne informacje. Zobacz Preferencje dotyczƒÖce plik√≥w cookie.

bool Model::LoadModel(const std::string& filePath)
{
    Assimp::Importer importer;

    const aiScene* pScene = importer.ReadFile(filePath, aiProcess_Triangulate | aiProcess_JoinIdenticalVertices |
        aiProcess_ConvertToLeftHanded | aiProcess_PreTransformVertices);

    if (pScene == nullptr)
        return false;

    ProcessNode(pScene->mRootNode, pScene);
    return true;
}

void Model::ProcessNode(aiNode* node, const aiScene* scene)
{
    for (UINT i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        meshes.push_back(this->ProcessMesh(mesh, scene));
    }
    for (UINT i = 0; i < node->mNumChildren; i++) {
        ProcessNode(node->mChildren[i], scene);
    }
}

Mesh Model::ProcessMesh(aiMesh* mesh, const aiScene* scene)
{
    //Data to fill
    std::vector<Vertex>vertices;
    std::vector<DWORD>indices;

    for (UINT i = 0; i < mesh->mNumVertices; i++) {
        Vertex vertex;
        vertex.pos.x = mesh->mVertices[i].x / 2;
        vertex.pos.y = mesh->mVertices[i].y / 2;
        vertex.pos.z = mesh->mVertices[i].z / 2;//  √∑2 to make model smaller

        if (mesh->mTextureCoords[0]) {
            vertex.texCoord.x = (float)mesh->mTextureCoords[0][i].x;
            vertex.texCoord.y = (float)mesh->mTextureCoords[0][i].y;
        }
        vertices.push_back(vertex);
    }

    for (UINT i = 0; i < mesh->mNumFaces; i++) {
        aiFace face = mesh->mFaces[i];

        for (UINT j = 0; j < face.mNumIndices; j++)
            indices.push_back(face.mIndices[j]);
    }

    return Mesh(device, deviceContext, vertices, indices);

}
Przejd≈∫ do tre≈õci

ChatGPT

Zaloguj siƒô
Powiedzia≈Çe≈õ(-a≈õ):
#include <SDL.h>
#include <GLES2/gl2.h>
#include <emscripten.h>
#include "loadObjMtl.h"
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

SDL_Window* window;
SDL_GLContext glContext;
Mesh mesh;
GLuint program, vbo, ibo, tex = 0;
std::unordered_map<std::string, Material> materials;

float rotX=0, rotY=0;
bool mouseDown=false;
int lastX, lastY;

const char* vs = R"(
attribute vec3 aPos;
attribute vec2 aUV;
attribute vec3 aNormal;

varying vec2 vUV;
varying vec3 vNormal;

uniform float rotX, rotY;

void main(){
    float cx = cos(rotX), sx=sin(rotX);
    float cy = cos(rotY), sy=sin(rotY);
    mat3 Rx = mat3(1,0,0, 0,cx,-sx, 0,sx,cx);
    mat3 Ry = mat3(cy,0,sy, 0,1,0, -sy,0,cy);
    vec3 p = Ry * Rx * aPos;
    gl_Position = vec4(p * 0.5 + vec3(0.0, 0.0, -1.0), 1.0);

    vUV = aUV;
    vNormal = normalize(Ry * Rx * aNormal);
}
)";

const char* fs = R"(
precision mediump float;

varying vec2 vUV;
varying vec3 vNormal;
uniform sampler2D tex;

void main() {
    vec3 lightDir = normalize(vec3(0.5, 1.0, 0.75));
    float diff = max(dot(vNormal, lightDir), 0.0);

    vec4 texColor = texture2D(tex, vUV);
    vec3 color = texColor.rgb * diff;

    gl_FragColor = vec4(color, texColor.a);
}
)";

GLuint compileShader(GLenum type, const char* source) {
    GLuint shader = glCreateShader(type);
    glShaderSource(shader, 1, &source, nullptr);
    glCompileShader(shader);

    GLint success;
    glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
    if (!success) {
        char infoLog[512];
        glGetShaderInfoLog(shader, 512, nullptr, infoLog);
        printf("Shader compilation failed: %s\n", infoLog);
        return 0;
    }
    return shader;
}

bool init(){
    SDL_Init(SDL_INIT_VIDEO);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION,2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
    window = SDL_CreateWindow("Obj+Mtl Loader", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800,600, SDL_WINDOW_OPENGL);
    glContext = SDL_GL_CreateContext(window);
    glViewport(0,0,800,600);

    glEnable(GL_DEPTH_TEST);
    glClearColor(1.0f, 0.1f, 0.1f, 1.0f);

    mesh = loadObjMtl("asserts/cube.obj", materials, "asserts/");
    printf("Verts: %zu, idx: %zu\n", mesh.vertices.size()/8, mesh.indices.size());

    GLuint vsId = compileShader(GL_VERTEX_SHADER, vs);
    GLuint fsId = compileShader(GL_FRAGMENT_SHADER, fs);
    program = glCreateProgram();
    glAttachShader(program, vsId);
    glAttachShader(program, fsId);
    glBindAttribLocation(program, 0, "aPos");
    glBindAttribLocation(program, 1, "aUV");
    glBindAttribLocation(program, 2, "aNormal");
    glLinkProgram(program);

    glGenBuffers(1,&vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, mesh.vertices.size()*sizeof(float), mesh.vertices.data(), GL_STATIC_DRAW);

    glGenBuffers(1,&ibo);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mesh.indices.size()*sizeof(unsigned int), mesh.indices.data(), GL_STATIC_DRAW);

    Material& mat = materials.begin()->second;
    int w,h,comp;
    unsigned char* data = stbi_load((std::string("asserts/")+mat.texPath).c_str(), &w,&h,&comp,4);
    if (!data) {
        printf("Failed to load texture: %s\n", (std::string("asserts/")+mat.texPath).c_str());
        return false;
    }
    glGenTextures(1,&tex);
    glBindTexture(GL_TEXTURE_2D, tex);
    glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,w,h,0,GL_RGBA,GL_UNSIGNED_BYTE,data);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
    stbi_image_free(data);

    glUseProgram(program);
    glUniform1i(glGetUniformLocation(program, "tex"), 0);

    return true;
}

void render(){
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glUseProgram(program);

    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)0);

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1,2,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)(3*sizeof(float)));

    glEnableVertexAttribArray(2);
    glVertexAttribPointer(2,3,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)(5*sizeof(float)));

    glUniform1f(glGetUniformLocation(program,"rotX"),rotX);
    glUniform1f(glGetUniformLocation(program,"rotY"),rotY);

    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_2D, tex);

    glDrawElements(GL_TRIANGLES, mesh.indices.size(), GL_UNSIGNED_INT, 0);

    SDL_GL_SwapWindow(window);
}

void loop(){
    SDL_Event e;
    while(SDL_PollEvent(&e)){
        if (e.type == SDL_QUIT) emscripten_cancel_main_loop();
        else if(e.type == SDL_MOUSEBUTTONDOWN && e.button.button == SDL_BUTTON_LEFT){
            mouseDown = true; lastX = e.button.x; lastY = e.button.y;
        } else if(e.type == SDL_MOUSEBUTTONUP && e.button.button == SDL_BUTTON_LEFT){
            mouseDown = false;
        } else if(e.type == SDL_MOUSEMOTION && mouseDown){
            rotY += (e.motion.x - lastX) * 0.01f;
            rotX += (e.motion.y - lastY) * 0.01f;
            lastX = e.motion.x; lastY = e.motion.y;
        }
    }
    render();
}

int main(){
    if (!init()) {
        printf("Initialization failed!\n");
        return 1;
    }
    emscripten_set_main_loop(loop, 0, 1);
    return 0;
}
WyciƒÖg mi z tego kodu wƒÖtek odpowiedzialny za ≈Çadowanie tekstury 
ChatGPT powiedzia≈Ç:
WƒÖtek odpowiedzialny za ≈Çadowanie tekstury znajduje siƒô w funkcji init(). Obejmuje on nastƒôpujƒÖce linie:

üîπ Fragment ≈Çadowania tekstury:
Material& mat = materials.begin()->second;
int w, h, comp;
unsigned char* data = stbi_load((std::string("asserts/") + mat.texPath).c_str(), &w, &h, &comp, 4);
if (!data) {
    printf("Failed to load texture: %s\n", (std::string("asserts/") + mat.texPath).c_str());
    return false;
}
glGenTextures(1, &tex);
glBindTexture(GL_TEXTURE_2D, tex);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
stbi_image_free(data);
üîç Co robi ten fragment?
Material& mat = materials.begin()->second;
Pobiera pierwszƒÖ strukturƒô Material z mapy materials (wcze≈õniej za≈ÇadowanƒÖ z .mtl).

stbi_load(...)
≈Åaduje obrazek (teksturƒô) z pliku do pamiƒôci jako tablicƒô bajt√≥w RGBA.

glGenTextures(...) i glBindTexture(...)
Tworzy i wiƒÖ≈ºe obiekt tekstury w OpenGL.

glTexImage2D(...)
Przesy≈Ça dane obrazu do GPU.

glTexParameteri(...)
Ustawia spos√≥b filtrowania tekstury (LINEAR = interpolacja).

stbi_image_free(data);
Zwalnia pamiƒôƒá zaalokowanƒÖ na dane obrazu.

Je≈õli chcesz wyodrƒôbniƒá ten kod jako osobnƒÖ funkcjƒô np. bool loadTexture(const std::string& path), mogƒô Ci to przerobiƒá.

Powiedzia≈Çe≈õ(-a≈õ):
Jak dasz radƒô a jak mia≈Ç za≈Çadowaƒá fbx teksturƒô jak mtl ?
ChatGPT powiedzia≈Ç:
‚úÖ Odpowied≈∫ kr√≥tka:
Plik FBX przechowuje tekstury wewnƒôtrznie (jako ≈õcie≈ºki do plik√≥w) ‚Äî podobnie jak MTL, ale w innym formacie i zwykle bardziej z≈Ço≈ºony (binarny lub ASCII).
Aby za≈Çadowaƒá teksturƒô z FBX, potrzebujesz parsera FBX, np.:

Assimp (najprostszy spos√≥b),

FBX SDK od Autodesk (oficjalny, ale ciƒô≈ºki i niekompatybilny z WebAssembly),

lub w≈Çasny parser (trudne, niezalecane).

üîç Por√≥wnanie: MTL vs FBX
Cecha	.MTL (dla .OBJ)	.FBX
Format	Tekstowy, prosty	Binarny/tekstowy, z≈Ço≈ºony
Tekstury	map_Kd texture.jpg	Zawarte jako ≈õcie≈ºki do plik√≥w
PowiƒÖzanie z geometriƒÖ	Przez usemtl w .obj	Wbudowane w strukturƒô FBX
≈Åadowanie	≈Åatwe ‚Äî wystarczy w≈Çasny parser	Trudne ‚Äî wymaga biblioteki/parsers
üì¶ Jak za≈Çadowaƒá teksturƒô z FBX ‚Äì z Assimp:
Je≈õli u≈ºywasz Assimp (Open Asset Import Library), to wyglƒÖda to tak:

üî∏ Pseudokod w C++:
Assimp::Importer importer;
const aiScene* scene = importer.ReadFile("model.fbx", aiProcess_Triangulate | aiProcess_FlipUVs);

if (scene && scene->HasMaterials()) {
    aiMaterial* material = scene->mMaterials[0]; // pierwszy materia≈Ç
    aiString texPath;
    if (material->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
        std::string fullPath = "asserts/" + std::string(texPath.C_Str());
        // za≈Çaduj teksturƒô jak w stbi_load(...)
    }
}
üß† Je≈õli nie u≈ºywasz Assimp:
FBX sam w sobie to bardzo skomplikowany format. Nie parsuj go rƒôcznie ‚Äî zamiast tego:

U≈ºyj narzƒôdzia offline (np. Blender) do eksportu FBX ‚Üí OBJ + MTL.

Lub skorzystaj z Assimp i odczytaj tekstury z aiMaterial.

‚úÖ TL;DR ‚Äî Jak za≈Çadowaƒá teksturƒô z FBX jak z MTL?
Nie da siƒô ≈Çatwo jak w .mtl przez map_Kd. Ale:

FBX zawiera ≈õcie≈ºki do tekstur,

mo≈ºesz je odczytaƒá przez Assimp (aiMaterial->GetTexture(...)),

dalej u≈ºywasz stbi_load(...) tak samo jak przy .mtl.

Chcesz przyk≈Çad loadFbx() przy u≈ºyciu Assimp?

Powiedzia≈Çe≈õ(-a≈õ):
Tak
ChatGPT powiedzia≈Ç:
≈öwietnie! Poni≈ºej masz kompletny przyk≈Çad funkcji loadFbx(), kt√≥ra:

Wczytuje plik .fbx (lub inny format obs≈Çugiwany przez Assimp),

Pobiera dane siatki i tekstury,

Tworzy strukturƒô Mesh (takƒÖ jak w Twoim kodzie),

≈Åaduje teksturƒô z pliku (np. JPG/PNG) za pomocƒÖ stb_image.

‚úÖ Zak≈Çadam:
Masz w≈Çasny typ Mesh z vertices i indices.

Chcesz mieƒá te≈º teksturƒô z materia≈Çu FBX.

Masz zaincludowane: assimp/Importer.hpp, assimp/scene.h, assimp/postprocess.h.

üß© Struktury i pomocnicze elementy:
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

#include <vector>
#include <string>

#include "stb_image.h"

struct Mesh {
    std::vector<float> vertices; // format: pos(3), uv(2), normal(3)
    std::vector<unsigned int> indices;
    std::string texturePath;
};
üîß Funkcja loadFbx():
Mesh loadFbx(const std::string& path, const std::string& baseDir) {
    Mesh mesh;
    Assimp::Importer importer;

    const aiScene* scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    if (!scene || !scene->HasMeshes()) {
        printf("Assimp error: %s\n", importer.GetErrorString());
        return mesh;
    }

    aiMesh* aMesh = scene->mMeshes[0];
    for (unsigned int i = 0; i < aMesh->mNumVertices; ++i) {
        aiVector3D pos = aMesh->mVertices[i];
        aiVector3D uv = aMesh->HasTextureCoords(0) ? aMesh->mTextureCoords[0][i] : aiVector3D(0,0,0);
        aiVector3D norm = aMesh->HasNormals() ? aMesh->mNormals[i] : aiVector3D(0,0,1);

        mesh.vertices.insert(mesh.vertices.end(), {
            pos.x, pos.y, pos.z,
            uv.x, uv.y,
            norm.x, norm.y, norm.z
        });
    }

    for (unsigned int i = 0; i < aMesh->mNumFaces; ++i) {
        const aiFace& face = aMesh->mFaces[i];
        for (unsigned int j = 0; j < face.mNumIndices; ++j)
            mesh.indices.push_back(face.mIndices[j]);
    }

    // Tekstura z materia≈Çu
    if (scene->HasMaterials()) {
        aiMaterial* mat = scene->mMaterials[aMesh->mMaterialIndex];
        aiString texPath;
        if (mat->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
            mesh.texturePath = baseDir + std::string(texPath.C_Str());
        }
    }

    return mesh;
}
üì¶ ≈Åadowanie tekstury (jak u Ciebie):
Po loadFbx():

int w,h,comp;
unsigned char* data = stbi_load(mesh.texturePath.c_str(), &w, &h, &comp, 4);
if (!data) {
    printf("Failed to load texture: %s\n", mesh.texturePath.c_str());
    // Obs≈Çu≈º b≈ÇƒÖd
}

glGenTextures(1, &tex);
glBindTexture(GL_TEXTURE_2D, tex);
glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
stbi_image_free(data);
‚úÖ Przyk≈Çad u≈ºycia:
Mesh mesh = loadFbx("assets/model.fbx", "assets/");
‚ùó Uwaga
Assimp wspiera wiele typ√≥w tekstur: aiTextureType_DIFFUSE, SPECULAR, NORMALS, itd. Je≈õli chcesz obs≈Çu≈ºyƒá wiƒôcej ‚Äî mogƒô rozbudowaƒá ten przyk≈Çad.

Chcesz te≈º, ≈ºebym przerobi≈Ç TwojƒÖ funkcjƒô loadObjMtl() na loadFbx()?

Powiedzia≈Çe≈õ(-a≈õ):
Tak
ChatGPT powiedzia≈Ç:
Super! Poni≈ºej przerobi≈Çem TwojƒÖ funkcjƒô loadObjMtl(...) tak, by dzia≈Ça≈Ça jako loadFbx(...) z u≈ºyciem Assimp, analogicznie do stylu i struktury Twojego kodu.

‚úÖ Funkcja loadFbx(...) ‚Äì zamiennik loadObjMtl(...)
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

#include "stb_image.h"
#include <unordered_map>

struct Material {
    std::string texPath;
};

Mesh loadFbx(const std::string& fbxPath, std::unordered_map<std::string, Material>& materials, const std::string& baseDir) {
    Mesh mesh;
    materials.clear();

    Assimp::Importer importer;

    const aiScene* scene = importer.ReadFile(fbxPath,
        aiProcess_Triangulate |
        aiProcess_FlipUVs |
        aiProcess_GenNormals |
        aiProcess_CalcTangentSpace);

    if (!scene || !scene->HasMeshes()) {
        printf("Assimp failed to load FBX: %s\n", importer.GetErrorString());
        return mesh;
    }

    aiMesh* aMesh = scene->mMeshes[0];

    for (unsigned int i = 0; i < aMesh->mNumVertices; ++i) {
        aiVector3D pos = aMesh->mVertices[i];
        aiVector3D uv = aMesh->HasTextureCoords(0) ? aMesh->mTextureCoords[0][i] : aiVector3D(0.0f, 0.0f, 0.0f);
        aiVector3D norm = aMesh->HasNormals() ? aMesh->mNormals[i] : aiVector3D(0.0f, 0.0f, 1.0f);

        mesh.vertices.insert(mesh.vertices.end(), {
            pos.x, pos.y, pos.z,
            uv.x, uv.y,
            norm.x, norm.y, norm.z
        });
    }

    for (unsigned int i = 0; i < aMesh->mNumFaces; ++i) {
        aiFace& face = aMesh->mFaces[i];
        for (unsigned int j = 0; j < face.mNumIndices; ++j) {
            mesh.indices.push_back(face.mIndices[j]);
        }
    }

    // Wczytaj materia≈Ç + teksturƒô
    if (scene->HasMaterials()) {
        aiMaterial* mat = scene->mMaterials[aMesh->mMaterialIndex];
        aiString texPath;
        if (mat->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
            Material m;
            m.texPath = texPath.C_Str();
            materials["default"] = m;
            printf("Texture path from FBX: %s\n", m.texPath.c_str());
        } else {
            printf("No diffuse texture found in FBX material.\n");
        }
    }

    return mesh;
}
‚úÖ Jak u≈ºywaƒá loadFbx() zamiast loadObjMtl() w init()
Zmie≈Ñ ten wiersz:

mesh = loadObjMtl("asserts/cube.obj", materials, "asserts/");
na:

mesh = loadFbx("asserts/model.fbx", materials, "asserts/");
Pamiƒôtaj: upewnij siƒô, ≈ºe Twoje .fbx ma teksturƒô (diffuse) i ≈ºe ≈õcie≈ºki wzglƒôdne w pliku FBX dzia≈ÇajƒÖ.

üì¶ Co jeszcze warto wiedzieƒá?
Assimp nie dzia≈Ça natywnie z Emscripten/WebAssembly ‚Äî trzeba go skompilowaƒá z odpowiednimi flagami lub korzystaƒá z prekompilowanej wersji.

FBX zapisany w ASCII z Blenderem ma wiƒôksze szanse na dzia≈Çanie w Assimp ni≈º binarny FBX.

Chcesz, ≈ºebym dostosowa≈Ç te≈º loader do FBX z wieloma teksturami lub materia≈Çami?
Daj znaƒá ‚Äî to tylko kilka linijek wiƒôcej.






Nie wybrano plikuNie wybrano pliku
Mesh loadMeshFromAssimp2(const std::string& path, std::unordered_map<std::string, Material>& materialsOut, const std::string& basePath) {
    Mesh mesh;
    Assimp::Importer importer;

    const aiScene* scene = importer.ReadFile(path,
        aiProcess_Triangulate | aiProcess_JoinIdenticalVertices | aiProcess_GenSmoothNormals | aiProcess_FlipUVs);

    if (!scene || !scene->HasMeshes()) {
        printf("Assimp error: %s\n", importer.GetErrorString());
        return mesh;
    }

    const aiMesh* m = scene->mMeshes[0];

    for (unsigned int i = 0; i < m->mNumVertices; ++i) {
        aiVector3D pos = m->mVertices[i];
        aiVector3D uv = m->HasTextureCoords(0) ? m->mTextureCoords[0][i] : aiVector3D(0, 0, 0);
        aiVector3D norm = m->mNormals[i];

        mesh.vertices.push_back(pos.x);
        mesh.vertices.push_back(pos.y);
        mesh.vertices.push_back(pos.z);

        mesh.vertices.push_back(uv.x);
        mesh.vertices.push_back(uv.y);

        mesh.vertices.push_back(norm.x);
        mesh.vertices.push_back(norm.y);
        mesh.vertices.push_back(norm.z);
    }

    for (unsigned int i = 0; i < m->mNumFaces; ++i) {
        aiFace& face = m->mFaces[i];
        for (unsigned int j = 0; j < face.mNumIndices; ++j)
            mesh.indices.push_back(face.mIndices[j]);
    }

    // Normalize model (center & scale)
    float minX=1e10f, maxX=-1e10f, minY=1e10f, maxY=-1e10f, minZ=1e10f, maxZ=-1e10f;
    for (size_t i = 0; i < mesh.vertices.size(); i += 8) {
        float x = mesh.vertices[i + 0];
        float y = mesh.vertices[i + 1];
        float z = mesh.vertices[i + 2];
        minX = std::min(minX, x); maxX = std::max(maxX, x);
        minY = std::min(minY, y); maxY = std::max(maxY, y);
        minZ = std::min(minZ, z); maxZ = std::max(maxZ, z);
    }
    float cx = (minX + maxX) / 2.f;
    float cy = (minY + maxY) / 2.f;
    float cz = (minZ + maxZ) / 2.f;
    float scale = 1.f / std::max({maxX - minX, maxY - minY, maxZ - minZ});
    for (size_t i = 0; i < mesh.vertices.size(); i += 8) {
        mesh.vertices[i + 0] = (mesh.vertices[i + 0] - cx) * scale;
        mesh.vertices[i + 1] = (mesh.vertices[i + 1] - cy) * scale;
        mesh.vertices[i + 2] = (mesh.vertices[i + 2] - cz) * scale;
    }

    // Load material texture path (only first diffuse texture)
    if (scene->HasMaterials()) {
        aiMaterial* mat = scene->mMaterials[m->mMaterialIndex];
        aiString texPath;
        if (mat->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
            Material material;
            material.texPath = std::string(texPath.C_Str());
            materialsOut["default"] = material;
        }
    }

    return mesh;
} mo≈ºe pope≈Çniaƒá b≈Çƒôdy. Sprawd≈∫ wa≈ºne informacje. Zobacz Preferencje dotyczƒÖce plik√≥w cookie.
